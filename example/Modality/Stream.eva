import Modality.Primitives

type Str(a) = Fix b --> a*b
type Ev(a) = Fix b--> a+b

let hdStr [a] # stream:Str(a) = 
    fst (out stream)

let tlStr [a] # stream:Str(a) = 
    snd (out stream)

let conStr [a] # (head: a) tail: >Str(a) = 
    into (head, tail) : Str(a)

let mapStr [a, b] f:#(a->b)= 
    rec m : # (Str(a) -> Str(b)) 
        => fun  str:Str(a) 
            => ?conStr[b] (?f (?hdStr[a] str)) ( > (<?m (<(?tlStr[a] str))))

let zipStr [a,b] = 
    rec m: # (Str(a)->Str(b) -> Str(a*b)) 
        => fun x:Str(a) y:Str(b) 
            => ?conStr[a*b] (?hdStr[a] x, ?hdStr[b] y) (> (<?m <(?tlStr[a] x) <(?tlStr[b] y) ) )

let fstStr[a,b] = 
    rec m: #(Str(a*b)->Str(a))
        => fun x:Str(a*b) 
            => ?conStr[a] (fst (?hdStr[a*b] x)) (> (<?m <(?tlStr[a*b] x)))
            
let sndStr[a,b] = 
    rec m: #(Str(a*b)->Str(b))
        => fun x:Str(a*b) 
            => ?conStr[b] (snd (?hdStr[a*b] x)) (> (<?m <(?tlStr[a*b] x)))

let constantStr [Stable a] = 
    rec m : # (a-> Str(a)) 
        => fun x: a 
            => ?conStr[a] x >(<?m x)

let delayStr [Stable a] = 
    rec m: # (a -> Str (a) -> Str(a)) 
        => fun x:a str:Str(a)
            => ?conStr[a] x  ((fun b:a => > (<?m  b <(?tlStr[a] str)) ) (?hdStr[a] str) )

/*
let wrongDelayStr [Stable a] = 
    rec m: # (a -> Str (a) -> Str(a)) 
        => fun x:a str:Str(a)
            => ?conStr[a] x  > (<?m  (?hdStr[a] str)  <(?tlStr[a] str)) 
*/