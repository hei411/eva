import Modality.Stream 

//RF stands for Regex Function
type RF = NFix x--> Bool->(Bool*x)




def null= 
    nfix loop:#(RF) => 
        let toFold = 
            fun b:Bool => 
                (false, ?loop)
        in 
        into toFold: RF

def epsilon #= 
    let toFold = 
        fun b:Bool => 
            (true, >?null)
    in 
    into toFold: RF

def matcht = 
    let tl #= 
        let toFold = 
            fun b:Bool => 
                (b, >?null)
        in 
        into toFold: RF
    in
    # (
        let toFold = 
            fun b:Bool => 
                (false, >?tl)
        in 
        into toFold: RF
    )

def matchf = 
    let tl #= 
        let toFold = 
            fun b:Bool => 
                (not b, >?null)
        in 
        into toFold: RF
    in 
    # (
        let toFold = 
            fun b:Bool => 
                (false, >?tl)
        in 
        into toFold: RF
    )

def orRF a:#RF b:#RF= 
    let helper = nfix loop:#(RF->RF->RF) => 
        fun one:RF two:RF => 
            let toFold = 
                fun b:Bool => 
                    let (resultOne,nextOne) = (out one) b in 
                    let (resultTwo, nextTwo) = (out two) b in 
                    (resultOne or resultTwo, >(<?loop <nextOne <nextTwo))
            in 
            into toFold: RF
    in 
    #(?helper ?a ?b)

    
def orRF' = 
    nfix loop:#(RF->RF->RF) => 
        fun one:RF two:RF => 
            let toFold = 
                fun b:Bool => 
                    let (resultOne,nextOne) = (out one) b in 
                    let (resultTwo, nextTwo) = (out two) b in 
                    (resultOne or resultTwo, >(<?loop <nextOne <nextTwo))
            in 
            into toFold: RF
    

def concatRF one:#RF two:#RF=
    let helper =
        nfix loop:#(RF ->RF) => 
            fun one' :RF => 
                let toFold = 
                    fun b:Bool => 
                        let (resultOne,nextOne) = (out one') b in 
                        let (resultTwo, nextTwo) = (out ?two) b in 
                        if resultOne 
                            then 
                            // match first 
                            let continue = >(<?loop <nextOne) in 
                            (resultTwo, >(?orRF' <continue <nextTwo))
                            else 
                            (false, >(<?loop <nextOne))

                in 
                into toFold: RF
    in
    #(?helper ?one)





def starRF initial:#RF= 
    let helper = 
        nfix loop:#(RF -> RF) => 
            fun rf:RF => 
                let toFold = 
                    fun b:Bool => 
                        let (resultrf,nextrf) = (out rf) b in 
                        let (resultinitial, nextinitial) = (out ?initial) b in 
                        if resultrf 
                            then 
                            //  continue matching current one 
                                let startNew = >(<?loop <nextinitial) in 
                                let continue = >(<?loop <nextrf) in 
                                (true, >(?orRF' <startNew <continue))
                            else 
                            (false, >(<?loop <nextrf))
                in 
                into toFold: RF
    in
    #( 
        ?helper ?epsilon
    )

def interpretRF initial:#RF = 
    let helper = 
        nfix loop:#( RF-> Str(Bool) ->Str(Bool))=> 
            fun rf:RF xs:Str(Bool) => 
                let x:::xs' = xs in 
                let (resultrf,nextrf) = (out rf) x in 
                resultrf:::>(<?loop <nextrf <xs')
    in 
    #(?helper ?initial)


def model =  concatRF (starRF matcht) matchf 


//for interactive testing 
//def main = interpretRF model

//for non-interactive testing
import Prelude.List as PL
def string = [true,true,false,false]
def convert  l:List(Bool) = 
    primrec l with 
        | [] => # now true :Bool Until Bool 
        | x::xs, rest => 
            # ( if ?PL.length{Bool} xs ==0 
                then  now x:Bool Until Bool 
                else 
                     wait x (@?rest)
                     )

def check  # l:Bool Until Bool = 
    urec l with 
        |now x => 
            fun rf:RF => 
                let (resultrf,nextrf) = (out rf) x in 
                now resultrf : Unit Until Bool 
        | wait x y, rest => 
            fun rf :RF => 
                let (resultrf,nextrf) = (out rf) x in 
                wait () @(<rest <nextrf)

def main # = 
    let l = ?(convert (true::string)) in 
    ?check l ?model