//def two_test = 2;
def test [a,b] f:a->b x:a=f x
def test2 = test [Nat,Unit]
def inlInsert [Stable a,b] # (var:a) = inl var :a+b
type Nattest (f,e) = Nat
type Weird(e,g) = e*(g+g)

import Prelude.Nat 

import Modality.Stream 
//def main  # = ?constantStr[Nat] 0 
def main  = if true and false and true then 0 else 3-5^2
//import ervrev.erg.erv;
/*
type Kef(s, b) = Nat;
type K = Unit;

def zero = 0;
def zero2 = zero;
def function = fun (k): Nat => suc suc 0;
def intofun = into 0 : Fix a ->Nat;
def inlfun = inl(0) : Nat + Unit;
//This is a comment

def q = fix e : # Fix a -> Nat + a => into(inr(unbox e)
                                             : (Nat + > Fix a->Nat + a)) : Fix a->Nat
                                            + a;

def primrectry =  fun x : Nat => primrec (x )with
                               | 0 => 0 
                               | suc k, t => t;

def urectry =#fun x : Nat Until Nat => urec(x) with
                                         | now x => suc 0 | wait x y, z => 0;

def embed = # fun x : @Nat  => > (adv x);
/*Comment block
heya
*/