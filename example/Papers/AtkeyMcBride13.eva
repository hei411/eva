//Programs from Productive Coprogramming with Guarded Recursion
//Robert Atkey and Conor McBride 2013

import Modality.Stream 

type Stream = Str(Nat) 

def ones = 
    rec loop:#Stream => 
        1::?loop

//filter can't be implemented as expected
/*def filter f:#(Nat->Bool) =
    rec loop:#(Stream->Stream) =>
        fun xs:Stream => 
            let x::xs' = xs in 
            if ?f x 
                then x::>(<?loop <xs')
            else >(<?loop <xs')*/

def mergef f:#(Nat->Nat-> > Stream -> Stream) = 
    rec loop:#(Stream->Stream->Stream) => 
        fun xs:Stream ys:Stream => 
            let x::xs' = xs in 
            let y::ys' = ys in 
            ?f x y >(<?loop <xs' <ys')

import Modality.UntilList 
type NatList = List(Nat)

//We use Until modality to encode finite lists
def take n:Nat  = 
    primrec n with 
        |0 =># fun xs:Stream => now () :NatList 
        |suc _, rest => 
            # fun xs:Stream =>
                let x::xs' = xs in 
                (wait x @(?rest <xs')) 

//debugging take
/*def constInt x:Nat = 
    rec loop:#Str(Nat) =>
        x::?loop

def test #= ?(take 8)   ?(constInt 4)*/

type Partial(a) =Ev(a)

