def add # x:Nat y:Nat = 
    primrec x with 
        | 0 => y
        | suc z, rest => suc rest 


def mult = 
#(fun (x:Nat) (y: Nat) => 
    primrec x with 
        | 0 => 0
        | suc z, rest => ?add y rest )


def exp # x:Nat y:Nat = 
    primrec y with 
        | 0 => 1
        | suc z, rest => ?mult x rest

def pred # x:Nat = 
    primrec x with
        |0=> 0
        |suc y, rest => y

def minus # x:Nat y:Nat = 
    primrec y with 
        | 0=> x
        | suc z, rest => ?pred rest

import Prelude.Bool

def isZero # x:Nat = 
    primrec x with 
        | 0 => true 
        | suc z, rest => false 

def equalsNat # x:Nat y:Nat =
    ?isZero (?add (?minus x y) (?minus y x))

def rem # x:Nat y:Nat = 
    primrec x with 
        | 0 => 0
        | suc m, rest => 
            ?if[Nat] (?equalsNat (?pred y) rest)
                0
                (suc rest) 

def div # x:Nat y:Nat = 
    ?if[Nat] (?isZero y) 0
    primrec x with 
        | 0=> 0
        | suc m, rest => 
            ?if[Nat] (?equalsNat (?rem m y) (?pred y))
                (suc rest)
                rest

def lessthan # x:Nat y:Nat = 
    ?isZero (?minus (suc x) y)

def leq #x:Nat y:Nat = 
    ?isZero (?minus x y)

def divisible # x:Nat y:Nat = 
    ?isZero (?rem x y)

def prime #x:Nat = 
    ?if[Bool] (?leq x 1)
        false 
        (primrec x with 
            | 0=> true 
            | suc m, rest => 
                ?and rest
                    (?or (?equalsNat (suc m) 1) 
                        (?or (?equalsNat (suc m) x)
                            (?not (?divisible x (suc m)))
                        )
                    )
        )

def min #x:Nat y:Nat = 
    ?if[Nat] (?leq x y)
        x
        y

def max #x:Nat y:Nat =
    ?if[Nat] (?leq x y)
        y 
        x

def gcd # x:Nat y:Nat =
    primrec (?min x y) with 
        |0=> 0
        |suc m, rest =>
            ?if[Nat] (?and (?divisible x (suc m)) (?divisible y (suc m)))
                (suc m)
                rest

def lcm # x:Nat y:Nat = 
    ?div (?mult x y) (?gcd x y)
    
def log # base:Nat x:Nat = 
    let f = (fun  ans:Nat b:Nat n:Nat => 
                let right = ?exp b (suc ans) in 
                let boolean = ?lessthan (suc n) right in 
                ?if[Nat] boolean ans (suc ans) 
            ) in 
    primrec x with 
        | 0 => 0 
        | suc n, rest => 
            f rest base n

def root# a:Nat = 
    primrec a with 
        | 0 => 
            let squared = ?mult a a in  
            ?if[Nat] (?lessthan a squared)
                (?pred a)
                a 
        | suc x, rest => 
            let tryNum = ?minus  a (suc x) in 
            let squared = ?mult tryNum tryNum in 
            ?if[Nat] (?lessthan a squared)
                (?pred tryNum)
                rest 