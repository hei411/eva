let two_test = 2;
let primrectry<ut, Stable gh, Limit po, Stable Limit p, Limit Stable j> = primrec xs<Nat, Unit, Types(Nat) *Unit> with | 0 => 0 | suc k fby t => t;

import ervrev.erg.erv;
type Kef(s, b) = Nat;
type K = Unit;

let zero = 0;
let zero2 = zero;
let function = fun (k): Nat => suc suc 0;
let intofun = into 0 : Fix a ->Nat;
let inlfun = inl(0) : Nat + Unit;
//This is a comment

let q = fix e : [] Fix a -> Nat + a => into(inr(unbox e)
                                             : (Nat + > Fix a->Nat + a)) : Fix a->Nat
                                            + a;

let primrectry =  fun x : Nat => primrec (x )with
                               | 0 => 0 
                               | suc k fby t => t;

let urectry = [] fun x : Nat Until Nat => urec(x) with
                                         | now x => suc 0 | wait x y fby z => 0;

let embed = [] fun x : @Nat  => > (adv x);
/*Comment block
heya
*/