//let two_test = 2;
let primrectry[a, Stable gh, Limit po, Stable Limit p, Limit Stable j]
    a:Nat b:Unit +j # (d:Fix a->a) 
    = primrec xs[gh+a, po, Fix a->a *Unit] with | 0 => <>?#@@0 | suc k fby t => <? t;

import ervrev.erg.erv;
/*
type Kef(s, b) = Nat;
type K = Unit;

let zero = 0;
let zero2 = zero;
let function = fun (k): Nat => suc suc 0;
let intofun = into 0 : Fix a ->Nat;
let inlfun = inl(0) : Nat + Unit;
//This is a comment

let q = fix e : # Fix a -> Nat + a => into(inr(unbox e)
                                             : (Nat + > Fix a->Nat + a)) : Fix a->Nat
                                            + a;

let primrectry =  fun x : Nat => primrec (x )with
                               | 0 => 0 
                               | suc k fby t => t;

let urectry =#fun x : Nat Until Nat => urec(x) with
                                         | now x => suc 0 | wait x y fby z => 0;

let embed = # fun x : @Nat  => > (adv x);
/*Comment block
heya
*/